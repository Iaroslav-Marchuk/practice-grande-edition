Глобальний контекст
У визначенні значення this є важливий нюанс. Значення this визначається не на момент оголошення функції (за винятком стрілкових функцій), а на момент її виклику.
Іншими словами, this визначається тим, як саме функцію викликали, а не де вона була оголошена.
    function foo() {
    console.log(this);
    }
    foo(); // window

У глобальному контексті, якщо функція виконується не в суворому режимі, this посилається на об'єкт window.
Об'єкт window надає доступ до браузерних властивостей і функцій та є глобальним контекстом виконання для скриптів у браузері.
У суворому режимі значення this у глобальному контексті завжди буде undefined.
    "use strict";
    function foo() {
    console.log(this);
    }
    foo(); // undefined

Контекст методу об'єкта
Якщо функція була викликана як метод об'єкта, то контекст вказуватиме на сам об'єкт, якому належить цей метод.
    const user = {
    username: "Poly",
    showThis() {
        console.log(this);
    }
    };
    user.showThis(); // {username: "Poly", showThis: ƒ}

Метод call()
Бувають ситуації, коли функцію потрібно викликати в контексті об'єкта, навіть якщо функція не є методом цього об'єкта.
Для цього у JavaScript існують спеціальні методи: call, apply і bind, які дозволяють вказати контекст виклику функції.
Вивчимо сигнатуру цього методу. Сигнатура — це ім'я методу і його параметри.
Сигнатура методу call**()** виглядає так:
    foo.call(thisArg, arg1, arg2, ...)
Метод call викликає функцію foo так, що значення this у функції буде посилатися на об'єкт thisArg, і також передає їй аргументи arg1, arg2 тощо.


Метод apply()
Метод apply є аналогом методу call. Відмінність у тому, що в методі apply() синтаксис передачі аргументів вимагає масиву, навіть якщо аргументи функції — це окремі значення.
Сигнатура методу apply**()** виглядає так:
    foo.apply(thisArg, [arg1, arg2, ...])
Метод apply викликає функцію foo таким чином, що значення this у функції буде посилатися на об'єкт obj і передасть елементи масиву як окремі аргументи arg1, arg2 тощо.


Метод bind() і втрата контексту
Методи call і apply викликають функцію «на місці», тобто одразу.
Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст, і ця нова функція може бути викликана пізніше з будь-якими аргументами.
Сигнатура методу bind() виглядає так:
    const boundFoo = foo.bind(thisArg, arg1, arg2, ...)


Метод bind() і колбеки
Метод bind() є дуже корисним. Особливо важливо його використовувати в колбек-функціях і ситуаціях, де можлива втрата контексту під час виклику функції.


Стрілочні функції
Контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.
Це означає, що this усередині стрілки посилається на контекст батьківської області видимості, в якій вона була оголошена, і ніколи не змінюється.
    const showThis = () => {
    console.log("this in showThis: ", this);
    };
    showThis(); // this in showThis: window
Навіть якщо присвоїти посилання на стрілочну функцію у властивість об'єкта і викликати її в контексті цього об'єкта, this усе одно буде посилатися на об'єкт, який функція запам'ятала в момент її оголошення.
Стрілочні функції також ігнорують наявність суворого режиму.
Якщо стрілка була оголошена в глобальному контексті, то this у ній буде містити посилання на window, незалежно від того, чи виконується скрипт у суворому режимі.
На відміну від звичайних функцій, змінити значення this усередині стрілки після її оголошення неможливо. Це означає, що методи call, apply і bind не впливають на значення this у стрілках.

Що треба запамятати про this у стрілочних функціях?
1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.
2.Стрілочні функції ігнорують наявність суворого режиму. Тому в глобальному контексті у стрілці завжди this посилається на об'єкт window.
3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення. Методи call, apply і bind не впливають на значення this у стрілках.

Алгоритм визначення this
Ключове слово this — це одна з найзаплутаніших концепцій для новачка.
Новачки часто підставляють this методом наукового тику доти, доки скрипт не спрацює.
Але все стає значно простішим, коли є простий алгоритм визначення значення this.

Крок 1
Це стрілочна функція?
    Якщо відповідь Так, значення this те саме, що у this у зовнішній області видимості
    Якщо відповідь Ні, переходь на Крок 2

Крок 2
Чи використовуються методи call, apply або bind?
    Якщо відповідь Так, значення this — це той самий об’єкт, що передали при їх виклику
    Якщо відповідь Ні, переходь на Крок 3

Крок 3
Функція викликається як метод об’єкта object.method?
    Якщо відповідь Так, значення this — це об’єкт ліворуч від крапки
    Якщо відповідь Ні, переходь на Крок 4

Крок 4
Скрипт виконується в суворому режимі?
    Якщо відповідь Так, значення this — undefined
    Якщо відповідь Ні, значення this — window