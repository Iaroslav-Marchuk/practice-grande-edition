Прототипи
Звідки беруться вбудовані методи масивів push, map, reduce та інші?
Чому у функції є методи call і bind?
Досі ми просто приймали, що вони є і ними можна користуватися. Прийшов час знайти відповіді на ці питання.
Усе це можливо завдяки механізму прототипного успадкування, який дає змогу організувати об'єкти в ланцюжки таким чином,
щоб здійснювався автоматичний пошук властивості в іншому об'єкті, якщо її не знайдено в поточному.
Сполучною ланкою виступає спеціальна службова властивість [[Prototype]], яку ми не змінюємо явно, вона використовується для автоматичного зв'язку об'єктів.

Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj.
прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку.


Перевірка прототипу
Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().
    objA.isPrototypeOf(objB)
    Метод перевіряє, чи є об'єкт objA прототипом для об’єкта objB
    Якщо так, повертає true, в іншому разі повертає false


Власні і невласні властивості
    const animal = {
    legs: 4,
    };
    const dog = Object.create(animal);
    dog.name = "Mango";

    console.log(dog); // {name: "Mango", [[Prototype]]: animal}
    console.log(dog.name); // "Mango"
    console.log(dog.legs); // 4

    Властивість name належить об'єкту dog, тому називається власною властивістю об'єкта dog.
    Властивість legs не належить об'єкту dog. Це властивість його прототипу animal, тому вона називається невласною властивістю об'єкта dog.

Для того щоб перевірити, чи є в об'єкті власна властивість, використовується метод obj.hasOwnProperty(key).
Цей метод перевіряє наявність власної властивості з ім'ям key і повертає true, якщо є, і false в іншому випадку.
    console.log(dog.hasOwnProperty("name")); // true
    console.log(dog.hasOwnProperty("legs")); // false


Перебір власних властивостей
Оператор in, який використовується в циклі for...in, не розрізняє власні властивості об'єкта і його прототипу. Ця особливість заважає, оскільки зазвичай потрібно перебрати тільки власні властивості.
Для вибору саме власних властивостей під час перебору циклом for...in необхідно на кожній ітерації додати перевірку на власну властивість методом obj.hasOwnProperty(key).
Цей метод повертає true, якщо властивість з іменем key належить об'єкту obj, а не його прототипу, в іншому разі — false.
    const animal = { legs: 4 };
    const dog = Object.create(animal);
    dog.name = "Mango";

    for (const key in dog) {
        if(dog.hasOwnProperty(key)) {
            console.log(key); // "name"
        }
    }

Методи Object.keys(obj) і Object.values(obj) повертають масив тільки власних ключів або значень тільки власних властивостей об'єкта obj, без необхідності додаткових перевірок.
Через це на практиці використовують саме їх із циклом for...of, замість for...in і hasOwnProperty.


Ланцюжки прототипів
Об'єкт, який виступає прототипом для іншого об'єкта, також може мати свій прототип. Отже, існують ланцюжки прототипів.


Кінець ланцюжка прототипів
Наприкінці ланцюжка прототипів завжди знаходиться посилання на базовий клас, від якого походить тип даних у ланцюжку.