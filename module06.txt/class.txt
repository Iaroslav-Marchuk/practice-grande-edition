Оголошення класу
Синтаксис літерала об'єкта дозволяє створити один об'єкт. Проте часто є потреба створити багато однотипних об'єктів з однаковим набором властивостей, але різними значеннями й методами для взаємодії з ними.
Все це потрібно робити динамічно, під час виконання програми. З цією метою використовують класи.
Оголошення класу має такий синтаксис:
    ключове слово class
    ім’я класу (у прикладі: User)
    тіло класу у фігурних дужках

class User {
  // Тіло класу
}

Класи прийнято називати з великої літери, а в назві відображати тип об'єкта (іменника), що створюється.


Після того як клас було оголошено, можна створити його екземпляр за допомогою спеціального оператора new, поставивши його перед викликом класу.
Результатом виклику new User() буде екземпляр класу User. Він буде містити дані і мати поведінку, що описані у класі.

class User {
  // Тіло класу
}

const mango = new User();
console.log(mango); // {}

const poly = new User();
console.log(poly); // {}


Конструктор класу
Для ініціалізації екземпляра класу використовується метод constructor.
Якщо його не визначити в явному вигляді, то буде створений конструктор за замовчуванням — порожня функція, яка не змінює екземпляр класу.

    class User {
    // Синтаксис оголошення методу класу
    constructor() {
            // ...
    }
    }

Виклик класу з оператором new призводить до створення нового об'єкта й автоматичного виклику методу constructor.
Аргументи, які передаються при виклику new User(), стають значеннями параметрів для методу constructor.
Зверни увагу, що метод constructor викликається в контексті створюваного екземпляра.
Таким чином, this усередині конструктора посилається на новостворений об'єкт.
Це дозволяє надавати кожному об'єкту властивості з однаковими іменами, але різними значеннями.


Об'єкт параметрів
Клас може приймати велику кількість вхідних даних для властивостей майбутнього об'єкта.
До них також можна застосувати патерн «Об'єкт параметрів», передаючи один об'єкт з логічно іменованими властивостями, замість непов'язаного набору аргументів.

class User {
  constructor(params) {
    this.name = params.name;
    this.email = params.email;
  }
}

Методи класу
Для роботи з властивостями майбутнього екземпляра використовуються методи класу.
Методи класу — це функції, які будуть доступні екземпляру в його прототипі. Вони оголошуються в довільному порядку після конструктора.
На відміну від синтаксису методів об'єкта (вони розділяються комою), методи класу не розділені жодними спеціальними символами.

class User {
  constructor(params) {
    this.name = params.name;
    this.email = params.email;
  }

  // Метод getEmail
  getEmail() {
		// ...
  }

  // Метод changeEmail
  changeEmail(newEmail) {
		// ...
  }
}

Для доступу до властивостей у методах використовується ключове слово this, оскільки методи будуть викликані в контексті об'єкта-екземпляра.
Після створення екземпляра можна використовувати оголошені методи класу, які будуть звертатися до властивостей об'єкта, що їх викликав.


Прототип екземпляру
Об'єктно-орієнтоване програмування в JavaScript побудоване на прототипному наслідуванні. Методи класу не стають власними властивостями екземпляра.
І це правильно, оскільки, на відміну від значень властивостей, вони не є унікальними. Це одна й та сама функція, яка викликається в контексті різних об'єктів.
Немає сенсу копіювати методи для кожного екземпляра, враховуючи, що може існувати багато тисяч екземплярів.
Методи класу додаються до спеціального об'єкта, який зберігається у властивості prototype самого класу.

При створенні екземпляра через new, об'єкт, збережений у властивості prototype класу, автоматично стає його прототипом.
Це означає, що властивість [[Prototype]] екземпляра отримує посилання на властивість prototype класу.

Завдяки цьому об'єкт-екземпляр може використовувати методи класу, тобто властивості свого прототипу.
Також у цьому об'єкті зберігається посилання на метод constructor класу, але це потрібно лише для внутрішніх механізмів класу і не має значення для нас.


Приватні властивості
Інкапсуляція — це парадигма ООП, яка передбачає приховування деталей внутрішньої реалізації класу від зовнішнього коду.
Інкапсуляція реалізується приватними властивостями та методами, доступ до яких можна отримати тільки всередині класу.
Припустимо, що пошта користувача повинна бути недоступною для прямої зміни ззовні, тобто приватною. Додаючи до імені властивості на початку символ #, ми робимо її приватною.
Оголошення приватної властивості до ініціалізації в конструкторі є обов'язковим.
Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.


Приватні методи
Іноді потрібно не просто отримувати або змінювати адресу електронної пошти, але й проводити певні дії, які мають бути приховані від "зовнішнього світу".
Скажімо, кожен раз, коли електронна пошта змінюється, потрібно валідувати її формат.
Це можна зробити за допомогою приватних методів. Додаючи до назви методу на початку символ #, ми робимо його приватним.


Геттери і сеттери
Геттери і сеттери — це спеціальний синтаксис оголошення методів для взаємодії з властивостями.
Геттер і сеттер імітують звичайну публічну властивість класу, але дозволяють взаємодіяти з іншими властивостями зручнішим способом.
Також вважається гарною практикою називати геттери і сеттери так само, як і властивість, з якою вони працюють. Це спрощує читання коду та його розуміння.
Коли інші розробники бачать геттер чи сеттер, який називається так само, як і властивість, вони можуть легко здогадатися, що цей метод служить для доступу до конкретної властивості.
Наприклад, геттер і сеттер для приватної властивості #email найлогічніше називати просто email.
Геттер і сеттер повинні називатися однаково. 
Краще називати геттери і сеттери так само, як і властивість, з якою вони працюють. Геттер може існувати без сеттера, так само як і сеттер без геттера.
еттери і сеттери доречно використовувати для простих операцій читання та зміни значення властивостей, особливо приватних, як їх публічний інтерфейс.
Для роботи з властивістю, яка зберігає масив або об'єкт, вони не підійдуть.


Статичні властивості
Крім публічних і приватних властивостей майбутнього екземпляра, у класі можна оголосити його власні властивості.
Властивості, що доступні тільки класові, але не його екземплярам — це статичні властивості. Вони корисні для зберігання інформації, що стосується класу.
Статичні властивості оголошуються в тілі класу. Перед ім'ям властивості додається ключове слово static. Статичні властивості можна використовувати як у методах класу, так і поза класом.


Статичні методи
У класі можна оголосити не тільки методи майбутнього екземпляра, а й статичні методи. Статичні методи — це методи, доступні тільки класу. Вони можуть бути публічні та приватні.
Синтаксис оголошення статичних методів майже аналогічний статичним властивостям. Єдина відмінність — значенням буде метод.
Особливість статичних методів 
Під час їх виклику ключове слово this посилається на сам клас. Це означає, що статичний метод може отримати доступ до статичних властивостей класу, але не до властивостей екземпляра.
Це логічно, адже статичні методи викликає сам клас, а не його екземпляри.


Наслідування класів
Ключове слово extends дозволяє реалізувати наслідування класів, коли один клас (дочірній, похідний) наслідує властивості й методи іншого класу (батьківського).
Це означає, що ми можемо оголосити базовий клас, який зберігає загальні характеристики й методи для групи похідних класів,
які наслідують властивості й методи батьківського, але також додають свої унікальні.


Конструктор дочірнього класу
У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.
В іншому випадку при спробі звернутися до this у конструкторі дочірнього класу виникне помилка.
Під час виклику конструктора батьківського класу передаємо необхідні йому аргументи для ініціалізації властивостей.


Методи дочірнього класу
Дочірній клас може використовувати методи та властивості батьківського класу. Крім цього, у дочірньому класі можна оголошувати методи, які будуть доступні тільки його екземплярам.